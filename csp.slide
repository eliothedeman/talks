Real World CSP
Look mom, no mutexes!
4 Mar 2016

Eliot Hedeman
Systems Developer, Deepfield Networks
eliot.d.hedeman@gmail.com
http://eliothedeman.com
@eliothedeman


* Who is this guy?
These are the things I work on:
.link https://github.com/eliothedeman/bangarang Bangarang
- Stream processor for monitoring applications
.link https://github.com/eliothedeman/immut Immut
- Collection of immutible/persistant data structures
.link https://github.com/glycerine/zygomys Zygomys
- LISP similar to colojure written in go


* Topics

Whats a CSP?
- _No_Code_

How does one CSP?
- _Some_Code_

Concurency building blocks
- _Mostly_Code_

Bow to Rob Pike
- _Gospel_music_and_speaking_in_tongues_


_"But_I_don't_know_go"_

Don't worry, just trust me


* What's a CSP?

*Definition*
In computer science, communicating sequential processes (CSP) is a formal language for describing patterns of interaction in concurrent systems.
# TODO define each word
- Based on a paper written by Tony Hoare in 1978
- Has morphed from a langauge that describes the behavior of programs into a set of concepts that we can use to structure concurrent programs in a sane and performant matter.

* Well "WTF is a concurrency?"

Well for one thing, it's not parallelism you idiot

According to Rob Pike...
"The composition of independently executing processes."

* Cont.

Concurrency = Dealing with a lot of things at once (Structure)
Parrallelism = Doing a lot of things at once (Execution)

.link http://blog.golang.org/concurrency-is-not-parallelism Concurrency is not parallelism - Rob Pike

* Example
.image img/cat1.png 200 900

* But I want to go fast... Double everything
.image img/cat2.png 400 900

Now we have something that, given multiple CPUs will be parallel. But it doesn't have to be.
This will exicute just fine on a single core machine.

* Problems with this approach.
- One pile could run out before the other, leaving gophers just sitting there.
- Shaving a cat takes way longer than taking it's picture. The picture taking gopher will just be hanging out.
- Plain wasteful if you want to scale even more.

* Another approach.
.image img/cat3.png 400 900

* Cont.
This archetecture allows any section of the pipeline to increase it's number of workers without changing the validity of the program.

* How does one CSP?
Now that we have seen what CSP can do, lets see what we need to make it happen.

* Communicaton (the "C" in CSP)

We need an efficient method of communication between our processes.

In go we have *channels*, which are much like pipes in the shell.
They allow for a/synchronous communication between goroutines

They are made like this...
.code examples/channel.go /1 OMIT/,/2 OMIT/

Send data on a channel like this...
.code examples/channel.go /3 OMIT/,/4 OMIT/

Receve data off a channel like this...
.code examples/channel.go /5 OMIT/,/6 OMIT/

* Channels are...

- Typed.
- Threadsafe.
- Really just threadsafe queues of a fixed size somewhere on the heap.
- Fun.
If you write to a channel and you fill it's size, it will block until someone reads.
If you read to a channel that is empty, it will block until someone writes.

By default all channels are of size zero, but you can make what is called a _buffered_channel_ by providing a size when you call make() as the second argument.
.code examples/channel.go /7 OMIT/,/8 OMIT/

* Execution (the "SP" in CSP)

We need an efficient method of running sequential code in a concurrent environmnet.

In go we have *goroutines*, which you can think of as extremely cheap threads.
Goroutines are started by prefixing a function call with the keyword _go_.

.code examples/goroutine.go /START OMIT/,/END OMIT/

* Goroutines are...

- Cleaned up/recycled by the runtime when they fall out of scope.
- Mapped to OS threads by the runtime.
- Extremely lightweight.
- Just as dangerous as threads when used in the wrong way.
- Easily abused.


* WONDER TWINS UNITE

.play  examples/channel.go /START OMIT/,/END OMIT/


* Pipelines

The pattern of kings.

- Always DAGs.
- Data ownership is given up when passed to a stage of the pipeline.
- Performance can be easily monitored and profiled by looking at the connection between stages.

* Example

Lets look at some functions we will use to modify strings (these are our "processes")

.code examples/sync_pipeline.go /1 OMIT/,/2 OMIT/
.code examples/sync_pipeline.go /3 OMIT/,/4 OMIT/
.code examples/sync_pipeline.go /5 OMIT/,/6 OMIT/

* In action
You have seen this pattern before.
.play examples/sync_pipeline.go /START OMIT/,/END OMIT/

But it is all happening in serial
.play examples/sync_pipeline2.go /START OMIT/,/END OMIT/

* But we want concurrency...
Lets make the functions processes!

* Quote
.code examples/async_pipeline.go /1 OMIT/,/2 OMIT/

* Cap
.code examples/async_pipeline.go /3 OMIT/,/4 OMIT/

* Explode
.code examples/async_pipeline.go /4 OMIT/,/6 OMIT/

* In action
.play examples/async_pipeline.go /START OMIT/,/END OMIT/

* We can do better
That was verbose as hell. But how do you factor out concurrency.

go back to the original functions
.code examples/sync_pipeline.go /1 OMIT/,/2 OMIT/
.code examples/sync_pipeline.go /3 OMIT/,/4 OMIT/
.code examples/sync_pipeline.go /5 OMIT/,/6 OMIT/

* Create a few interfaces and a wrapper
.code examples/async_pipeline2.go /1 OMIT/,/2 OMIT/

* And we can use it like such
.play examples/async_pipeline2.go /START OMIT/,/END OMIT/

* Select

In *UNIX*:
A really awesome syscall that lets you wait on a number of file descriptors until one or more of them is available for an IO action.

- Greatly simplifies the concept of using the availability of information as a control structure.
- Super gross and hard to use for non experts (Myself included)

In *Go*
A really awesome control structure that lets you wait on a number of channels until one or more of them is available for an IO action.

- Greatly simplifies the concept of using the availability of information as a control structure.
- Super clean and easy to use.
- Easy way to introduce deadlocks if you don't understand who is doing what when.

* Lets race
Scott and Nolen are going to race to see who can count to ten the fastest.

To do this we need two things.

- A way to count and signal when counting complete.
- A way to receive the signal that counting is complete.

* Count and signal
.code examples/select.go /1 OMIT/,/2 OMIT/

* Decide the winner
.play examples/select.go /START OMIT/,/END OMIT/

* Timeouts
Select makes timeouts easy
.play examples/timeout.go /START OMIT/,/END OMIT/
