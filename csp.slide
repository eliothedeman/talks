Real World CSP
Look mom, no mutexes!
4 Mar 2016

Eliot Hedeman
Systems Developer, Deepfield Networks
eliot.d.hedeman@gmail.com
http://eliothedeman.com
@eliothedeman


* Who is this guy?
These are the things I work on:
.link https://github.com/eliothedeman/bangarang Bangarang
- Stream processor for monitoring applications
.link https://github.com/eliothedeman/immut Immut
- Collection of immutible/persistant data structures
.link https://github.com/glycerine/zygomys Zygomys
- LISP similar to colojure written in go
.link https://github.com/prometheus/prometheus Prometheus
- Monitoring system and time series database.

* CSP (Communicating Sequential Processes)
_"Don't_communicate_by_sharing_memory._Share_memory_by_communicating_. "
-- Rob Pike

* My thoughts on rob pike...

.image img/notworthy.gif

* What's a CSP?

In computer science, CSP is a formal language for describing patterns of interaction in concurrent systems.

- Based on a paper written by Tony Hoare in 1978
- Has morphed from a language that describes the behavior of programs into a set of concepts that we can use to structure concurrent programs in a sane and performant manner.

.image img/vending.svg

* Communication

The imparting or interchange of information.

* Sequence

The following of one thing after another.

* Process

A systematic series of actions directed to some end.

* Example
        cat /var/log/syslog | grep api | of=/dev/floppy0

* Principles (Unofficial)

- Processes have one or more inputs.
- Processes have one or more outputs.
- Ownership of data is given up when passed to the next process.
- Anything can be communicated, even processes.
- Only concern yourself with the connection between processes, not the function of the processes.
- If you want to go faster, do more work.

* Well "WTF is a concurrency?"

Well for one thing, it's not parallelism.

According to Rob Pike...
"The composition of independently executing processes."

* Cont.

Concurrency = Dealing with a lot of things at once (Structure)
Parrallelism = Doing a lot of things at once (Execution)

.link http://blog.golang.org/concurrency-is-not-parallelism Concurrency is not parallelism - Rob Pike

* Example
.image img/cat1.png 200 900

* But I want to go fast... Double everything
.image img/cat2.png 400 900

Now we have something that, given multiple CPUs will be parallel. But it doesn't have to be.
This will execute just fine on a single core machine.

* Problems with this approach.
- One pile could run out before the other, leaving gophers just sitting there.
- Shaving a cat takes way longer than taking it's picture. The picture taking gopher will just be hanging out.
- Plain wasteful if you want to scale even more.

* Another approach.
.image img/cat3.png 400 900

* Cont.
This architecture allows any section of the pipeline to increase it's number of workers without changing the validity of the program.

* How does one CSP?
Now that we have seen what CSP can do, lets see what we need to make it happen.

* Communication (the "C" in CSP)

We need an efficient method of communication between our processes.

In go we have *channels*, which are much like pipes in the shell.
They allow for a/synchronous communication between goroutines

They are made like this...
.code examples/channel.go /1 OMIT/,/2 OMIT/

Send data on a channel like this...
.code examples/channel.go /3 OMIT/,/4 OMIT/

Receive data off a channel like this...
.code examples/channel.go /5 OMIT/,/6 OMIT/

* Channels are...

- Typed.
- Thread-safe.
- Really just thread-safe queues of a fixed size somewhere on the heap.
- Fun.
If you write to a channel and you fill it's size, it will block until someone reads.
If you read to a channel that is empty, it will block until someone writes.

By default all channels are of size zero, but you can make what is called a _buffered_channel_ by providing a size when you call make() as the second argument.
.code examples/channel.go /7 OMIT/,/8 OMIT/

* Execution (the "SP" in CSP)

We need an efficient method of running sequential code in a concurrent environment.

In go we have *goroutines*, which you can think of as extremely cheap threads.
Goroutines are started by prefixing a function call with the keyword _go_.

.code examples/goroutine.go /START OMIT/,/END OMIT/

* Goroutines are...

- Cleaned up/recycled by the runtime when they fall out of scope.
- Mapped to OS threads by the runtime.
- Extremely lightweight.
- Just as dangerous as threads when used in the wrong way.
- Easily abused.


* WONDER TWINS UNITE

.play  examples/channel.go /START OMIT/,/END OMIT/


* Pipelines

The pattern of kings.

- Always DAGs.
- Data ownership is given up when passed to a stage of the pipeline.
- Performance can be easily monitored and profiled by looking at the connection between stages.

* Example

Lets look at some functions we will use to modify strings (these are our "processes")

.code examples/sync_pipeline.go /1 OMIT/,/2 OMIT/
.code examples/sync_pipeline.go /3 OMIT/,/4 OMIT/
.code examples/sync_pipeline.go /5 OMIT/,/6 OMIT/

* In action
You have seen this pattern before.
.play examples/sync_pipeline.go /START OMIT/,/END OMIT/

But it is all happening in serial
.play examples/sync_pipeline2.go /START OMIT/,/END OMIT/

* But we want concurrency...
Lets make the functions processes!

* Quote
.code examples/async_pipeline.go /1 OMIT/,/2 OMIT/

* Cap
.code examples/async_pipeline.go /3 OMIT/,/4 OMIT/

* Explode
.code examples/async_pipeline.go /4 OMIT/,/6 OMIT/

* In action
.play examples/async_pipeline.go /START OMIT/,/END OMIT/

* We can do better
That was verbose as hell. But how do you factor out concurrency.

go back to the original functions
.code examples/sync_pipeline.go /1 OMIT/,/2 OMIT/
.code examples/sync_pipeline.go /3 OMIT/,/4 OMIT/
.code examples/sync_pipeline.go /5 OMIT/,/6 OMIT/

* Create a few interfaces and a wrapper
.code examples/async_pipeline2.go /1 OMIT/,/2 OMIT/

* And we can use it like such
.play examples/async_pipeline2.go /START OMIT/,/END OMIT/

* Select

In *UNIX*:
A really awesome syscall that lets you wait on a number of file descriptors until one or more of them is available for an IO action.

- Greatly simplifies the concept of using the availability of information as a control structure.
- Super gross and hard to use for non experts (Myself included)

In *Go*
A really awesome control structure that lets you wait on a number of channels until one or more of them is available for an IO action.

- Greatly simplifies the concept of using the availability of information as a control structure.
- Super clean and easy to use.
- Easy way to introduce deadlocks if you don't understand who is doing what when.

* Lets race
Scott and Nolen are going to race to see who can count to ten the fastest.

To do this we need two things.

- A way to count and signal when counting complete.
- A way to receive the signal that counting is complete.

* Count and signal
.code examples/select.go /1 OMIT/,/2 OMIT/

* Decide the winner
.play examples/select.go /START OMIT/,/END OMIT/

* Now lets build something serious

.image img/walk.gif 400 500

* Lets write a game

Rules:
- Guess a number between 0 and n * 10. Where n = the round # + 1.
- The first player to guess the number gets n points.
- The first player to get 100 points wins.

* Define the processes
- Player - Guess random numbers within a given range.
- Referee - Check the random numbers against the secret number and report correct guesses.
- Scoreboard - Keep track of the score and report the end of the game.
